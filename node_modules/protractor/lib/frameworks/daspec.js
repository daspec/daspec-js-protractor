var util = require('util'),
    q = require('q'),
    log = require('../logger');
var testResult = [],
    failedCount = 0;
/**
 * A debug framework which does not actually run any tests, just spits
 * out the list that would be run.
 *
 * @param {Runner} runner The current Protractor Runner.
 * @param {Array} specs Array of Directory Path Strings.
 * @return {q.Promise} Promise resolved with the test results
 */
exports.run = function (runner, specs) {

    var DaSpecConsoleRunner = require('daspec/src/console-runner'),
        execOptions = ['node', 'node_modules/.bin/daspec'],
        daspecResolvedRequire;

    if (runner.getConfig().daSpecOptions) {
        if (runner.getConfig().daSpecOptions.steps) {
            execOptions.push('--steps');
            execOptions.push(runner.getConfig().daSpecOptions.steps);
        }
    }
    execOptions = execOptions.concat(specs);

    function stepResult() {
        console.log('stepResult');
    }

    return runner.runTestPreparer().then(function () {
        return q.promise(function (resolve, reject) {
            config = {
                "encoding": "utf8",
                "formatters": ["../../../../node_modules/daspec/formatters/markdown-files", "../../../../node_modules/daspec/formatters/console"]
            };
            Object.keys(runner.getConfig().daSpecOptions).forEach(function (key) {
                config[key] = runner.getConfig().daSpecOptions[key];
            });
            var runtime = new ProtractorRunner(runner, config);
            var result = runtime.run();
            resolve({
                failedCount: failedCount,
                specResults: testResult
            });
        });
    });
};

/*global module, require */

var glob = require('glob'),
    DaSpec = require('daspec/node_modules/daspec-core'),
    vm = require('vm'),
    path = require('path'),
    fs = require('fs');
function ProtractorRunner(protractorRunner, config) {
    'use strict';
    var self = this,
        outputDir = config['output-dir'],
        fsOptions = {encoding: (config.encoding || 'utf8')},
        checkConfig = function () {
            if (!outputDir) {
                throw 'Output directory is not defined -- re-run with --help to see config arguments';
            }
            if (!config.specs || config.specs.length === 0) {
                throw 'No specs defined for this run -- re-run with --help to see config arguments';
            }
            if (!config.steps || config.steps.length === 0) {
                throw 'No steps defined for this run  -- re-run with --help to see config arguments';
            }
        },
        checkFiles = function (files) {
            if (files.steps.length === 0) {
                throw 'No step files match the list provided:' + config.steps;
            }
            if (files.specs.length === 0) {
                throw 'No spec files match the list provided:' + config.specs;
            }
        },
        toScript = function (sourcePath) {
            var source = fs.readFileSync(sourcePath, fsOptions);
            return new vm.Script(source, sourcePath);
        };
    self.run = function () {
        var files = {specs: [], steps: [], sources: []},
            sourceScripts,
            defineSteps = function () {
                sourceScripts.forEach(function (script) {
                    script.runInThisContext();
                });
                files.steps.forEach(function (filePath) {
                    require(path.resolve(filePath));
                });
            },
            runner,
            addFormatters = function () {
                config.formatters.forEach(function (module) {
                    require(module)(runner, config);
                });
            },
            globFiles = function () {
                Object.keys(files).forEach(function (key) {
                    if (config[key]) {
                        config[key].forEach(function (pattern) {
                            files[key] = files[key].concat(glob.sync(pattern));
                        });
                    }
                });
            },
            remapMatchers = function () {
                if (config.matchers) {
                    config.matchers = config.matchers.map(require);
                }
            },
            specs;
        checkConfig();
        globFiles();
        remapMatchers();
        checkFiles(files);
        var stepResults = {
            description: null,
            assertions: [],
            duration: 0
        };

        function specEnded(name, assertions) {
            var specInfo = {
                name: name,
                category: name
            };
            if (assertions.failed > 0) {
                failedCount += 1;
                protractorRunner.emit('testFail', specInfo);
            } else {
                protractorRunner.emit('testPass', specInfo);
            }
        }

        function allAssertionsPass(element, index, array) {
            return element === true;
        }

        function stepResult(result) {
            if (result.assertions.every(allAssertionsPass)) {
                stepResults.assertions.push({
                    passed: true
                });
            } else {
                stepResults.assertions.push({
                    passed: false,
                    errorMsg: 'this is my error message'
                });
            }
            testResult.push(stepResults)
        }

        specs = files.specs.map(function (specFile) {
            var getSource = function () {
                return fs.readFileSync(specFile, fsOptions);
            };
            return {name: specFile, content: getSource};
        });
        sourceScripts = files.sources.map(toScript);
        runner = new DaSpec.Runner(defineSteps, config);
        runner.addEventListener('stepResult', stepResult);
        runner.addEventListener('specEnded', specEnded);
        addFormatters();
        return runner.executeSuite(specs);
    };
};
